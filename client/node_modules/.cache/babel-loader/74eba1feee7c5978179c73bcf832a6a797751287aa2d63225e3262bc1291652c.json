{"ast":null,"code":"var _jsxFileName = \"D:\\\\Data\\\\Project\\\\claude ai\\\\BookMyServiceV2\\\\client\\\\src\\\\utils\\\\simplifiedMessagingService.js\",\n  _s = $RefreshSig$(),\n  _s2 = $RefreshSig$();\n// client/src/utils/simplifiedMessagingService.js\nimport React, { createContext, useState, useContext, useEffect, useCallback } from 'react';\nimport api from './api';\n\n// Create a messaging context\nimport { jsxDEV as _jsxDEV } from \"react/jsx-dev-runtime\";\nconst MessagingContext = /*#__PURE__*/createContext(null);\nexport const MessagingProvider = ({\n  children\n}) => {\n  _s();\n  const [activeConversationId, setActiveConversationId] = useState(null);\n  const [activeThreadId, setActiveThreadId] = useState(null);\n  const [messages, setMessages] = useState([]);\n  const [isLoading, setIsLoading] = useState(false);\n  const [error, setError] = useState(null);\n  const [pollingInterval, setPollingInterval] = useState(null);\n  const [totalPages, setTotalPages] = useState(1);\n  const [hasMore, setHasMore] = useState(false);\n\n  // Fetch messages for the active thread\n  const fetchMessages = useCallback(async (threadId, page = 1, showLoading = true) => {\n    if (!threadId) return null;\n    try {\n      if (showLoading) {\n        setIsLoading(true);\n      }\n      setError(null);\n      const response = await api.get(`/messages/thread/${threadId}/messages?page=${page}`);\n      if (response.data) {\n        if (page === 1) {\n          // First page, replace all messages\n          setMessages(response.data.messages || []);\n        } else {\n          // Subsequent pages, prepend to existing messages\n          setMessages(prev => [...(response.data.messages || []), ...prev]);\n        }\n\n        // Set pagination info\n        setTotalPages(response.data.totalPages || 1);\n        setHasMore(page < (response.data.totalPages || 1));\n        return response.data;\n      }\n      return null;\n    } catch (err) {\n      console.error('Error fetching messages:', err);\n      setError('Failed to load messages');\n      return null;\n    } finally {\n      if (showLoading) {\n        setIsLoading(false);\n      }\n    }\n  }, []);\n\n  // Set active conversation and thread\n  const setActiveChat = useCallback((conversationId, threadId) => {\n    setActiveConversationId(conversationId);\n    setActiveThreadId(threadId);\n\n    // Clear existing messages when changing conversation/thread\n    setMessages([]);\n    setTotalPages(1);\n    setHasMore(false);\n\n    // Start polling for new messages\n    if (threadId) {\n      // Clear any existing polling interval\n      if (pollingInterval) {\n        clearInterval(pollingInterval);\n      }\n\n      // Fetch messages immediately\n      fetchMessages(threadId);\n\n      // Then set up polling every 3 seconds\n      const interval = setInterval(() => {\n        fetchMessages(threadId, 1, false);\n      }, 3000);\n      setPollingInterval(interval);\n    }\n  }, [fetchMessages, pollingInterval]);\n\n  // Clean up polling when component unmounts\n  useEffect(() => {\n    return () => {\n      if (pollingInterval) {\n        clearInterval(pollingInterval);\n      }\n    };\n  }, [pollingInterval]);\n\n  // Send a message\n  const sendMessage = useCallback(async (content, attachments = []) => {\n    if (!activeThreadId || !content.trim() && attachments.length === 0) return null;\n    try {\n      const response = await api.post(`/messages/thread/${activeThreadId}`, {\n        content: content.trim(),\n        attachments\n      });\n\n      // Add the new message to the current messages\n      if (response.data) {\n        setMessages(prev => [...prev, response.data]);\n\n        // Fetch messages right after sending to ensure consistency\n        setTimeout(() => {\n          fetchMessages(activeThreadId, 1, false);\n        }, 500);\n      }\n      return response.data;\n    } catch (err) {\n      console.error('Error sending message:', err);\n      setError('Failed to send message');\n      return null;\n    }\n  }, [activeThreadId, fetchMessages]);\n\n  // Load more messages (pagination)\n  const loadMoreMessages = useCallback(async page => {\n    if (!activeThreadId) return null;\n    const result = await fetchMessages(activeThreadId, page);\n    if (result) {\n      setHasMore(page < result.totalPages);\n      return result;\n    }\n    return null;\n  }, [activeThreadId, fetchMessages]);\n\n  // Get or create a conversation thread\n  const getOrCreateThread = useCallback(async (conversationId, type, entityId = null) => {\n    try {\n      let endpoint;\n      if (type === 'general') {\n        endpoint = `/messages/conversation/${conversationId}/thread/general`;\n      } else if (type === 'order' && entityId) {\n        endpoint = `/messages/conversation/${conversationId}/thread/order/${entityId}`;\n      } else if (type === 'gig' && entityId) {\n        endpoint = `/messages/conversation/${conversationId}/thread/gig/${entityId}`;\n      } else {\n        throw new Error('Invalid thread type or missing entity ID');\n      }\n      const response = await api.get(endpoint);\n      return response.data;\n    } catch (err) {\n      console.error('Error getting thread:', err);\n      setError('Failed to get or create thread');\n      return null;\n    }\n  }, []);\n\n  // Clean up when changing conversations\n  useEffect(() => {\n    // When activeThreadId changes, fetch messages right away\n    if (activeThreadId) {\n      fetchMessages(activeThreadId);\n\n      // Set up polling for new messages\n      const interval = setInterval(() => {\n        fetchMessages(activeThreadId, 1, false);\n      }, 3000);\n      setPollingInterval(interval);\n      return () => {\n        if (pollingInterval) {\n          clearInterval(pollingInterval);\n        }\n      };\n    }\n  }, [activeThreadId, fetchMessages]);\n\n  // Context value\n  const value = {\n    activeConversationId,\n    activeThreadId,\n    messages,\n    isLoading,\n    error,\n    hasMore,\n    totalPages,\n    setActiveChat,\n    sendMessage,\n    loadMoreMessages,\n    getOrCreateThread\n  };\n  return /*#__PURE__*/_jsxDEV(MessagingContext.Provider, {\n    value: value,\n    children: children\n  }, void 0, false, {\n    fileName: _jsxFileName,\n    lineNumber: 196,\n    columnNumber: 5\n  }, this);\n};\n\n// Custom hook to use the messaging context\n_s(MessagingProvider, \"tEPfmHtDSRAeXHq0s9irEnNYcX4=\");\n_c = MessagingProvider;\nexport const useMessaging = () => {\n  _s2();\n  const context = useContext(MessagingContext);\n  if (!context) {\n    throw new Error('useMessaging must be used within a MessagingProvider');\n  }\n  return context;\n};\n_s2(useMessaging, \"b9L3QQ+jgeyIrH0NfHrJ8nn7VMU=\");\nvar _c;\n$RefreshReg$(_c, \"MessagingProvider\");","map":{"version":3,"names":["React","createContext","useState","useContext","useEffect","useCallback","api","jsxDEV","_jsxDEV","MessagingContext","MessagingProvider","children","_s","activeConversationId","setActiveConversationId","activeThreadId","setActiveThreadId","messages","setMessages","isLoading","setIsLoading","error","setError","pollingInterval","setPollingInterval","totalPages","setTotalPages","hasMore","setHasMore","fetchMessages","threadId","page","showLoading","response","get","data","prev","err","console","setActiveChat","conversationId","clearInterval","interval","setInterval","sendMessage","content","attachments","trim","length","post","setTimeout","loadMoreMessages","result","getOrCreateThread","type","entityId","endpoint","Error","value","Provider","fileName","_jsxFileName","lineNumber","columnNumber","_c","useMessaging","_s2","context","$RefreshReg$"],"sources":["D:/Data/Project/claude ai/BookMyServiceV2/client/src/utils/simplifiedMessagingService.js"],"sourcesContent":["// client/src/utils/simplifiedMessagingService.js\r\nimport React, { createContext, useState, useContext, useEffect, useCallback } from 'react';\r\nimport api from './api';\r\n\r\n// Create a messaging context\r\nconst MessagingContext = createContext(null);\r\n\r\nexport const MessagingProvider = ({ children }) => {\r\n  const [activeConversationId, setActiveConversationId] = useState(null);\r\n  const [activeThreadId, setActiveThreadId] = useState(null);\r\n  const [messages, setMessages] = useState([]);\r\n  const [isLoading, setIsLoading] = useState(false);\r\n  const [error, setError] = useState(null);\r\n  const [pollingInterval, setPollingInterval] = useState(null);\r\n  const [totalPages, setTotalPages] = useState(1);\r\n  const [hasMore, setHasMore] = useState(false);\r\n\r\n  // Fetch messages for the active thread\r\n  const fetchMessages = useCallback(async (threadId, page = 1, showLoading = true) => {\r\n    if (!threadId) return null;\r\n    \r\n    try {\r\n      if (showLoading) {\r\n        setIsLoading(true);\r\n      }\r\n      setError(null);\r\n      \r\n      const response = await api.get(`/messages/thread/${threadId}/messages?page=${page}`);\r\n      \r\n      if (response.data) {\r\n        if (page === 1) {\r\n          // First page, replace all messages\r\n          setMessages(response.data.messages || []);\r\n        } else {\r\n          // Subsequent pages, prepend to existing messages\r\n          setMessages(prev => [...response.data.messages || [], ...prev]);\r\n        }\r\n        \r\n        // Set pagination info\r\n        setTotalPages(response.data.totalPages || 1);\r\n        setHasMore(page < (response.data.totalPages || 1));\r\n        \r\n        return response.data;\r\n      }\r\n      return null;\r\n    } catch (err) {\r\n      console.error('Error fetching messages:', err);\r\n      setError('Failed to load messages');\r\n      return null;\r\n    } finally {\r\n      if (showLoading) {\r\n        setIsLoading(false);\r\n      }\r\n    }\r\n  }, []);\r\n\r\n  // Set active conversation and thread\r\n  const setActiveChat = useCallback((conversationId, threadId) => {\r\n    setActiveConversationId(conversationId);\r\n    setActiveThreadId(threadId);\r\n    \r\n    // Clear existing messages when changing conversation/thread\r\n    setMessages([]);\r\n    setTotalPages(1);\r\n    setHasMore(false);\r\n    \r\n    // Start polling for new messages\r\n    if (threadId) {\r\n      // Clear any existing polling interval\r\n      if (pollingInterval) {\r\n        clearInterval(pollingInterval);\r\n      }\r\n      \r\n      // Fetch messages immediately\r\n      fetchMessages(threadId);\r\n      \r\n      // Then set up polling every 3 seconds\r\n      const interval = setInterval(() => {\r\n        fetchMessages(threadId, 1, false);\r\n      }, 3000);\r\n      \r\n      setPollingInterval(interval);\r\n    }\r\n  }, [fetchMessages, pollingInterval]);\r\n\r\n  // Clean up polling when component unmounts\r\n  useEffect(() => {\r\n    return () => {\r\n      if (pollingInterval) {\r\n        clearInterval(pollingInterval);\r\n      }\r\n    };\r\n  }, [pollingInterval]);\r\n\r\n  // Send a message\r\n  const sendMessage = useCallback(async (content, attachments = []) => {\r\n    if (!activeThreadId || !content.trim() && attachments.length === 0) return null;\r\n    \r\n    try {\r\n      const response = await api.post(`/messages/thread/${activeThreadId}`, {\r\n        content: content.trim(),\r\n        attachments\r\n      });\r\n      \r\n      // Add the new message to the current messages\r\n      if (response.data) {\r\n        setMessages(prev => [...prev, response.data]);\r\n        \r\n        // Fetch messages right after sending to ensure consistency\r\n        setTimeout(() => {\r\n          fetchMessages(activeThreadId, 1, false);\r\n        }, 500);\r\n      }\r\n      \r\n      return response.data;\r\n    } catch (err) {\r\n      console.error('Error sending message:', err);\r\n      setError('Failed to send message');\r\n      return null;\r\n    }\r\n  }, [activeThreadId, fetchMessages]);\r\n\r\n  // Load more messages (pagination)\r\n  const loadMoreMessages = useCallback(async (page) => {\r\n    if (!activeThreadId) return null;\r\n    \r\n    const result = await fetchMessages(activeThreadId, page);\r\n    if (result) {\r\n      setHasMore(page < result.totalPages);\r\n      return result;\r\n    }\r\n    return null;\r\n  }, [activeThreadId, fetchMessages]);\r\n\r\n  // Get or create a conversation thread\r\n  const getOrCreateThread = useCallback(async (conversationId, type, entityId = null) => {\r\n    try {\r\n      let endpoint;\r\n      \r\n      if (type === 'general') {\r\n        endpoint = `/messages/conversation/${conversationId}/thread/general`;\r\n      } else if (type === 'order' && entityId) {\r\n        endpoint = `/messages/conversation/${conversationId}/thread/order/${entityId}`;\r\n      } else if (type === 'gig' && entityId) {\r\n        endpoint = `/messages/conversation/${conversationId}/thread/gig/${entityId}`;\r\n      } else {\r\n        throw new Error('Invalid thread type or missing entity ID');\r\n      }\r\n      \r\n      const response = await api.get(endpoint);\r\n      return response.data;\r\n    } catch (err) {\r\n      console.error('Error getting thread:', err);\r\n      setError('Failed to get or create thread');\r\n      return null;\r\n    }\r\n  }, []);\r\n\r\n  // Clean up when changing conversations\r\n  useEffect(() => {\r\n    // When activeThreadId changes, fetch messages right away\r\n    if (activeThreadId) {\r\n      fetchMessages(activeThreadId);\r\n      \r\n      // Set up polling for new messages\r\n      const interval = setInterval(() => {\r\n        fetchMessages(activeThreadId, 1, false);\r\n      }, 3000);\r\n      \r\n      setPollingInterval(interval);\r\n      \r\n      return () => {\r\n        if (pollingInterval) {\r\n          clearInterval(pollingInterval);\r\n        }\r\n      };\r\n    }\r\n  }, [activeThreadId, fetchMessages]);\r\n\r\n  // Context value\r\n  const value = {\r\n    activeConversationId,\r\n    activeThreadId,\r\n    messages,\r\n    isLoading,\r\n    error,\r\n    hasMore,\r\n    totalPages,\r\n    setActiveChat,\r\n    sendMessage,\r\n    loadMoreMessages,\r\n    getOrCreateThread\r\n  };\r\n\r\n  return (\r\n    <MessagingContext.Provider value={value}>\r\n      {children}\r\n    </MessagingContext.Provider>\r\n  );\r\n};\r\n\r\n// Custom hook to use the messaging context\r\nexport const useMessaging = () => {\r\n  const context = useContext(MessagingContext);\r\n  if (!context) {\r\n    throw new Error('useMessaging must be used within a MessagingProvider');\r\n  }\r\n  return context;\r\n};"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}