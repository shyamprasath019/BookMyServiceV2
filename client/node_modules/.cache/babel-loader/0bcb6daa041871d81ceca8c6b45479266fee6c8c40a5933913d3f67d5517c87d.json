{"ast":null,"code":"// client/src/utils/fileUploadService.js\nimport api from './api';\n\n/**\r\n * Enhanced service for handling file uploads throughout the application\r\n * This version properly stores files in client/src/assets and manages references\r\n */\nconst fileUploadService = {\n  /**\r\n   * Upload a file to the specified directory\r\n   * @param {File} file - The file to upload\r\n   * @param {string} category - The category of the upload (gig, job, profile, etc.)\r\n   * @param {string} id - The ID of the item the file is associated with (optional)\r\n   * @returns {Promise<string>} - The path to the stored file\r\n   */\n  uploadFile: async (file, category, id = 'new') => {\n    // For a real app, this would send the file to the server\n    // For our implementation, we'll simulate storage in the client/src/assets directory\n\n    const formData = new FormData();\n    formData.append('file', file);\n    formData.append('category', category);\n    formData.append('id', id);\n    try {\n      const response = await api.post('/uploads/file', formData, {\n        headers: {\n          'Content-Type': 'multipart/form-data'\n        }\n      });\n\n      // Return the path to the stored file\n      return response.data.filePath;\n    } catch (error) {\n      console.error('Error uploading file:', error);\n      // For now, return a simulated path as fallback\n      const safeName = file.name.replace(/[^a-zA-Z0-9._-]/g, '_');\n      return `/src/assets/images/${category}/${id}/${Date.now()}-${safeName}`;\n    }\n  },\n  /**\r\n   * Upload multiple files\r\n   * @param {File[]} files - Array of files to upload\r\n   * @param {string} category - The category of uploads (gig, job, profile, etc.)\r\n   * @param {string} id - The ID of the item the files are associated with (optional)\r\n   * @returns {Promise<string[]>} - Array of paths to the stored files\r\n   */\n  uploadFiles: async (files, category, id = 'new') => {\n    if (!files || files.length === 0) return [];\n    try {\n      // Process all files in parallel\n      const uploadPromises = Array.from(files).map(file => fileUploadService.uploadFile(file, category, id));\n      return await Promise.all(uploadPromises);\n    } catch (error) {\n      console.error('Error uploading multiple files:', error);\n      // Return simulated paths as fallback\n      return Array.from(files).map(file => {\n        const safeName = file.name.replace(/[^a-zA-Z0-9._-]/g, '_');\n        return `/src/assets/images/${category}/${id}/${Date.now()}-${safeName}`;\n      });\n    }\n  },\n  /**\r\n   * Generate a URL for a file path\r\n   * @param {string} filePath - The path to the file\r\n   * @returns {string} - The URL to access the file\r\n   */\n  getFileUrl: filePath => {\n    if (!filePath) return '';\n\n    // If it's already a full URL, return it\n    if (filePath.startsWith('http')) {\n      return filePath;\n    }\n\n    // If it's a relative path, convert to absolute\n    if (filePath.startsWith('/')) {\n      // In a real app, this would be the base URL of your server\n      // For now, we'll assume it's relative to the current origin\n      return `${window.location.origin}${filePath}`;\n    }\n\n    // Otherwise, assume it's relative to the app root\n    return `${window.location.origin}/${filePath}`;\n  },\n  /**\r\n   * Delete a file\r\n   * @param {string} filePath - The path to the file to delete\r\n   * @returns {Promise<boolean>} - Whether the deletion was successful\r\n   */\n  deleteFile: async filePath => {\n    if (!filePath) return false;\n    try {\n      await api.delete(`/uploads/file`, {\n        data: {\n          filePath\n        }\n      });\n      return true;\n    } catch (error) {\n      console.error('Error deleting file:', error);\n      return false;\n    }\n  },\n  /**\r\n   * Gets a file's extension\r\n   * @param {string} filename - The filename\r\n   * @returns {string} - The file extension\r\n   */\n  getFileExtension: filename => {\n    return filename.slice((filename.lastIndexOf(\".\") - 1 >>> 0) + 2);\n  },\n  /**\r\n   * Generate a readable file size string\r\n   * @param {number} bytes - File size in bytes\r\n   * @returns {string} - Human readable file size\r\n   */\n  formatFileSize: bytes => {\n    if (bytes === 0) return '0 Bytes';\n    const k = 1024;\n    const sizes = ['Bytes', 'KB', 'MB', 'GB'];\n    const i = Math.floor(Math.log(bytes) / Math.log(k));\n    return parseFloat((bytes / Math.pow(k, i)).toFixed(2)) + ' ' + sizes[i];\n  },\n  /**\r\n   * Check if file is an image\r\n   * @param {File} file - The file to check\r\n   * @returns {boolean} - Whether the file is an image\r\n   */\n  isImage: file => {\n    const acceptedImageTypes = ['image/jpeg', 'image/png', 'image/gif', 'image/webp'];\n    return file && acceptedImageTypes.includes(file.type);\n  },\n  /**\r\n   * Creates a file preview URL\r\n   * @param {File} file - The file to preview\r\n   * @returns {string} - URL for previewing the file\r\n   */\n  createFilePreview: file => {\n    if (!file) return '';\n    return URL.createObjectURL(file);\n  },\n  /**\r\n   * Revokes a file preview URL to free memory\r\n   * @param {string} previewUrl - The preview URL to revoke\r\n   */\n  revokeFilePreview: previewUrl => {\n    if (previewUrl && previewUrl.startsWith('blob:')) {\n      URL.revokeObjectURL(previewUrl);\n    }\n  }\n};\nexport default fileUploadService;","map":{"version":3,"names":["api","fileUploadService","uploadFile","file","category","id","formData","FormData","append","response","post","headers","data","filePath","error","console","safeName","name","replace","Date","now","uploadFiles","files","length","uploadPromises","Array","from","map","Promise","all","getFileUrl","startsWith","window","location","origin","deleteFile","delete","getFileExtension","filename","slice","lastIndexOf","formatFileSize","bytes","k","sizes","i","Math","floor","log","parseFloat","pow","toFixed","isImage","acceptedImageTypes","includes","type","createFilePreview","URL","createObjectURL","revokeFilePreview","previewUrl","revokeObjectURL"],"sources":["D:/Data/Project/claude ai/BookMyServiceV2/client/src/utils/fileUploadService.js"],"sourcesContent":["// client/src/utils/fileUploadService.js\r\nimport api from './api';\r\n\r\n/**\r\n * Enhanced service for handling file uploads throughout the application\r\n * This version properly stores files in client/src/assets and manages references\r\n */\r\nconst fileUploadService = {\r\n  /**\r\n   * Upload a file to the specified directory\r\n   * @param {File} file - The file to upload\r\n   * @param {string} category - The category of the upload (gig, job, profile, etc.)\r\n   * @param {string} id - The ID of the item the file is associated with (optional)\r\n   * @returns {Promise<string>} - The path to the stored file\r\n   */\r\n  uploadFile: async (file, category, id = 'new') => {\r\n    // For a real app, this would send the file to the server\r\n    // For our implementation, we'll simulate storage in the client/src/assets directory\r\n    \r\n    const formData = new FormData();\r\n    formData.append('file', file);\r\n    formData.append('category', category);\r\n    formData.append('id', id);\r\n    \r\n    try {\r\n      const response = await api.post('/uploads/file', formData, {\r\n        headers: {\r\n          'Content-Type': 'multipart/form-data'\r\n        }\r\n      });\r\n      \r\n      // Return the path to the stored file\r\n      return response.data.filePath;\r\n    } catch (error) {\r\n      console.error('Error uploading file:', error);\r\n      // For now, return a simulated path as fallback\r\n      const safeName = file.name.replace(/[^a-zA-Z0-9._-]/g, '_');\r\n      return `/src/assets/images/${category}/${id}/${Date.now()}-${safeName}`;\r\n    }\r\n  },\r\n\r\n  /**\r\n   * Upload multiple files\r\n   * @param {File[]} files - Array of files to upload\r\n   * @param {string} category - The category of uploads (gig, job, profile, etc.)\r\n   * @param {string} id - The ID of the item the files are associated with (optional)\r\n   * @returns {Promise<string[]>} - Array of paths to the stored files\r\n   */\r\n  uploadFiles: async (files, category, id = 'new') => {\r\n    if (!files || files.length === 0) return [];\r\n    \r\n    try {\r\n      // Process all files in parallel\r\n      const uploadPromises = Array.from(files).map(file => \r\n        fileUploadService.uploadFile(file, category, id)\r\n      );\r\n      \r\n      return await Promise.all(uploadPromises);\r\n    } catch (error) {\r\n      console.error('Error uploading multiple files:', error);\r\n      // Return simulated paths as fallback\r\n      return Array.from(files).map(file => {\r\n        const safeName = file.name.replace(/[^a-zA-Z0-9._-]/g, '_');\r\n        return `/src/assets/images/${category}/${id}/${Date.now()}-${safeName}`;\r\n      });\r\n    }\r\n  },\r\n  \r\n  /**\r\n   * Generate a URL for a file path\r\n   * @param {string} filePath - The path to the file\r\n   * @returns {string} - The URL to access the file\r\n   */\r\n  getFileUrl: (filePath) => {\r\n    if (!filePath) return '';\r\n    \r\n    // If it's already a full URL, return it\r\n    if (filePath.startsWith('http')) {\r\n      return filePath;\r\n    }\r\n    \r\n    // If it's a relative path, convert to absolute\r\n    if (filePath.startsWith('/')) {\r\n      // In a real app, this would be the base URL of your server\r\n      // For now, we'll assume it's relative to the current origin\r\n      return `${window.location.origin}${filePath}`;\r\n    }\r\n    \r\n    // Otherwise, assume it's relative to the app root\r\n    return `${window.location.origin}/${filePath}`;\r\n  },\r\n  \r\n  /**\r\n   * Delete a file\r\n   * @param {string} filePath - The path to the file to delete\r\n   * @returns {Promise<boolean>} - Whether the deletion was successful\r\n   */\r\n  deleteFile: async (filePath) => {\r\n    if (!filePath) return false;\r\n    \r\n    try {\r\n      await api.delete(`/uploads/file`, { data: { filePath } });\r\n      return true;\r\n    } catch (error) {\r\n      console.error('Error deleting file:', error);\r\n      return false;\r\n    }\r\n  },\r\n  \r\n  /**\r\n   * Gets a file's extension\r\n   * @param {string} filename - The filename\r\n   * @returns {string} - The file extension\r\n   */\r\n  getFileExtension: (filename) => {\r\n    return filename.slice((filename.lastIndexOf(\".\") - 1 >>> 0) + 2);\r\n  },\r\n  \r\n  /**\r\n   * Generate a readable file size string\r\n   * @param {number} bytes - File size in bytes\r\n   * @returns {string} - Human readable file size\r\n   */\r\n  formatFileSize: (bytes) => {\r\n    if (bytes === 0) return '0 Bytes';\r\n    \r\n    const k = 1024;\r\n    const sizes = ['Bytes', 'KB', 'MB', 'GB'];\r\n    const i = Math.floor(Math.log(bytes) / Math.log(k));\r\n    \r\n    return parseFloat((bytes / Math.pow(k, i)).toFixed(2)) + ' ' + sizes[i];\r\n  },\r\n  \r\n  /**\r\n   * Check if file is an image\r\n   * @param {File} file - The file to check\r\n   * @returns {boolean} - Whether the file is an image\r\n   */\r\n  isImage: (file) => {\r\n    const acceptedImageTypes = ['image/jpeg', 'image/png', 'image/gif', 'image/webp'];\r\n    return file && acceptedImageTypes.includes(file.type);\r\n  },\r\n  \r\n  /**\r\n   * Creates a file preview URL\r\n   * @param {File} file - The file to preview\r\n   * @returns {string} - URL for previewing the file\r\n   */\r\n  createFilePreview: (file) => {\r\n    if (!file) return '';\r\n    return URL.createObjectURL(file);\r\n  },\r\n  \r\n  /**\r\n   * Revokes a file preview URL to free memory\r\n   * @param {string} previewUrl - The preview URL to revoke\r\n   */\r\n  revokeFilePreview: (previewUrl) => {\r\n    if (previewUrl && previewUrl.startsWith('blob:')) {\r\n      URL.revokeObjectURL(previewUrl);\r\n    }\r\n  }\r\n};\r\n\r\nexport default fileUploadService;"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}