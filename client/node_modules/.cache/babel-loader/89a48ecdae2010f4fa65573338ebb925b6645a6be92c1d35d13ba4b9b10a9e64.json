{"ast":null,"code":"var _jsxFileName = \"D:\\\\Data\\\\Project\\\\claude ai\\\\BookMyServiceV2\\\\client\\\\src\\\\utils\\\\simplifiedMessagingService.js\",\n  _s = $RefreshSig$(),\n  _s2 = $RefreshSig$();\n// client/src/utils/simplifiedMessagingService.js\nimport React, { createContext, useState, useContext, useEffect, useCallback } from 'react';\nimport api from './api';\n\n// Create a messaging context\nimport { jsxDEV as _jsxDEV } from \"react/jsx-dev-runtime\";\nconst MessagingContext = /*#__PURE__*/createContext(null);\nexport const MessagingProvider = ({\n  children\n}) => {\n  _s();\n  const [activeConversationId, setActiveConversationId] = useState(null);\n  const [activeThreadId, setActiveThreadId] = useState(null);\n  const [messages, setMessages] = useState([]);\n  const [isLoading, setIsLoading] = useState(false);\n  const [error, setError] = useState(null);\n  const [pollingInterval, setPollingInterval] = useState(null);\n\n  // Fetch messages for the active thread\n  const fetchMessages = useCallback(async (threadId, page = 1) => {\n    if (!threadId) return;\n    try {\n      setIsLoading(true);\n      setError(null);\n      const response = await api.get(`/messages/thread/${threadId}/messages?page=${page}`);\n      if (page === 1) {\n        // First page, replace all messages\n        setMessages(response.data.messages);\n      } else {\n        // Subsequent pages, prepend to existing messages\n        setMessages(prev => [...response.data.messages, ...prev]);\n      }\n      return response.data;\n    } catch (err) {\n      console.error('Error fetching messages:', err);\n      setError('Failed to load messages');\n      return null;\n    } finally {\n      setIsLoading(false);\n    }\n  }, []);\n\n  // Set active conversation and thread\n  const setActiveChat = useCallback((conversationId, threadId) => {\n    setActiveConversationId(conversationId);\n    setActiveThreadId(threadId);\n\n    // Clear existing messages when changing conversation/thread\n    setMessages([]);\n\n    // Start polling for new messages\n    if (threadId) {\n      // Clear any existing polling interval\n      if (pollingInterval) {\n        clearInterval(pollingInterval);\n      }\n\n      // Fetch messages immediately\n      fetchMessages(threadId);\n\n      // Then set up polling every 5 seconds\n      const interval = setInterval(() => {\n        fetchMessages(threadId);\n      }, 5000);\n      setPollingInterval(interval);\n    }\n  }, [fetchMessages, pollingInterval]);\n\n  // Clean up polling when component unmounts\n  useEffect(() => {\n    return () => {\n      if (pollingInterval) {\n        clearInterval(pollingInterval);\n      }\n    };\n  }, [pollingInterval]);\n\n  // Send a message\n  const sendMessage = useCallback(async (content, attachments = []) => {\n    if (!activeThreadId || !content.trim()) return null;\n    try {\n      const response = await api.post(`/messages/thread/${activeThreadId}`, {\n        content: content.trim(),\n        attachments\n      });\n\n      // Add the new message to the current messages\n      setMessages(prev => [...prev, response.data]);\n      return response.data;\n    } catch (err) {\n      console.error('Error sending message:', err);\n      setError('Failed to send message');\n      return null;\n    }\n  }, [activeThreadId]);\n\n  // Load more messages (pagination)\n  const loadMoreMessages = useCallback(async page => {\n    if (!activeThreadId) return null;\n    return fetchMessages(activeThreadId, page);\n  }, [activeThreadId, fetchMessages]);\n\n  // Get or create a conversation thread\n  const getOrCreateThread = useCallback(async (conversationId, type, entityId = null) => {\n    try {\n      let endpoint;\n      if (type === 'general') {\n        endpoint = `/messages/conversation/${conversationId}/thread/general`;\n      } else if (type === 'order' && entityId) {\n        endpoint = `/messages/conversation/${conversationId}/thread/order/${entityId}`;\n      } else if (type === 'gig' && entityId) {\n        endpoint = `/messages/conversation/${conversationId}/thread/gig/${entityId}`;\n      } else {\n        throw new Error('Invalid thread type or missing entity ID');\n      }\n      const response = await api.get(endpoint);\n      return response.data;\n    } catch (err) {\n      console.error('Error getting thread:', err);\n      setError('Failed to get or create thread');\n      return null;\n    }\n  }, []);\n\n  // Clean up when changing conversations\n  useEffect(() => {\n    return () => {\n      if (pollingInterval) {\n        clearInterval(pollingInterval);\n      }\n      setActiveThreadId(null);\n      setMessages([]);\n    };\n  }, [activeConversationId]);\n\n  // Context value\n  const value = {\n    activeConversationId,\n    activeThreadId,\n    messages,\n    isLoading,\n    error,\n    setActiveChat,\n    sendMessage,\n    loadMoreMessages,\n    getOrCreateThread\n  };\n  return /*#__PURE__*/_jsxDEV(MessagingContext.Provider, {\n    value: value,\n    children: children\n  }, void 0, false, {\n    fileName: _jsxFileName,\n    lineNumber: 156,\n    columnNumber: 5\n  }, this);\n};\n\n// Custom hook to use the messaging context\n_s(MessagingProvider, \"dJ1L8+qZZOdXlaVuGqcpIf07SCU=\");\n_c = MessagingProvider;\nexport const useMessaging = () => {\n  _s2();\n  const context = useContext(MessagingContext);\n  if (!context) {\n    throw new Error('useMessaging must be used within a MessagingProvider');\n  }\n  return context;\n};\n_s2(useMessaging, \"b9L3QQ+jgeyIrH0NfHrJ8nn7VMU=\");\nvar _c;\n$RefreshReg$(_c, \"MessagingProvider\");","map":{"version":3,"names":["React","createContext","useState","useContext","useEffect","useCallback","api","jsxDEV","_jsxDEV","MessagingContext","MessagingProvider","children","_s","activeConversationId","setActiveConversationId","activeThreadId","setActiveThreadId","messages","setMessages","isLoading","setIsLoading","error","setError","pollingInterval","setPollingInterval","fetchMessages","threadId","page","response","get","data","prev","err","console","setActiveChat","conversationId","clearInterval","interval","setInterval","sendMessage","content","attachments","trim","post","loadMoreMessages","getOrCreateThread","type","entityId","endpoint","Error","value","Provider","fileName","_jsxFileName","lineNumber","columnNumber","_c","useMessaging","_s2","context","$RefreshReg$"],"sources":["D:/Data/Project/claude ai/BookMyServiceV2/client/src/utils/simplifiedMessagingService.js"],"sourcesContent":["// client/src/utils/simplifiedMessagingService.js\r\nimport React, { createContext, useState, useContext, useEffect, useCallback } from 'react';\r\nimport api from './api';\r\n\r\n// Create a messaging context\r\nconst MessagingContext = createContext(null);\r\n\r\nexport const MessagingProvider = ({ children }) => {\r\n  const [activeConversationId, setActiveConversationId] = useState(null);\r\n  const [activeThreadId, setActiveThreadId] = useState(null);\r\n  const [messages, setMessages] = useState([]);\r\n  const [isLoading, setIsLoading] = useState(false);\r\n  const [error, setError] = useState(null);\r\n  const [pollingInterval, setPollingInterval] = useState(null);\r\n\r\n  // Fetch messages for the active thread\r\n  const fetchMessages = useCallback(async (threadId, page = 1) => {\r\n    if (!threadId) return;\r\n    \r\n    try {\r\n      setIsLoading(true);\r\n      setError(null);\r\n      \r\n      const response = await api.get(`/messages/thread/${threadId}/messages?page=${page}`);\r\n      \r\n      if (page === 1) {\r\n        // First page, replace all messages\r\n        setMessages(response.data.messages);\r\n      } else {\r\n        // Subsequent pages, prepend to existing messages\r\n        setMessages(prev => [...response.data.messages, ...prev]);\r\n      }\r\n      \r\n      return response.data;\r\n    } catch (err) {\r\n      console.error('Error fetching messages:', err);\r\n      setError('Failed to load messages');\r\n      return null;\r\n    } finally {\r\n      setIsLoading(false);\r\n    }\r\n  }, []);\r\n\r\n  // Set active conversation and thread\r\n  const setActiveChat = useCallback((conversationId, threadId) => {\r\n    setActiveConversationId(conversationId);\r\n    setActiveThreadId(threadId);\r\n    \r\n    // Clear existing messages when changing conversation/thread\r\n    setMessages([]);\r\n    \r\n    // Start polling for new messages\r\n    if (threadId) {\r\n      // Clear any existing polling interval\r\n      if (pollingInterval) {\r\n        clearInterval(pollingInterval);\r\n      }\r\n      \r\n      // Fetch messages immediately\r\n      fetchMessages(threadId);\r\n      \r\n      // Then set up polling every 5 seconds\r\n      const interval = setInterval(() => {\r\n        fetchMessages(threadId);\r\n      }, 5000);\r\n      \r\n      setPollingInterval(interval);\r\n    }\r\n  }, [fetchMessages, pollingInterval]);\r\n\r\n  // Clean up polling when component unmounts\r\n  useEffect(() => {\r\n    return () => {\r\n      if (pollingInterval) {\r\n        clearInterval(pollingInterval);\r\n      }\r\n    };\r\n  }, [pollingInterval]);\r\n\r\n  // Send a message\r\n  const sendMessage = useCallback(async (content, attachments = []) => {\r\n    if (!activeThreadId || !content.trim()) return null;\r\n    \r\n    try {\r\n      const response = await api.post(`/messages/thread/${activeThreadId}`, {\r\n        content: content.trim(),\r\n        attachments\r\n      });\r\n      \r\n      // Add the new message to the current messages\r\n      setMessages(prev => [...prev, response.data]);\r\n      \r\n      return response.data;\r\n    } catch (err) {\r\n      console.error('Error sending message:', err);\r\n      setError('Failed to send message');\r\n      return null;\r\n    }\r\n  }, [activeThreadId]);\r\n\r\n  // Load more messages (pagination)\r\n  const loadMoreMessages = useCallback(async (page) => {\r\n    if (!activeThreadId) return null;\r\n    return fetchMessages(activeThreadId, page);\r\n  }, [activeThreadId, fetchMessages]);\r\n\r\n  // Get or create a conversation thread\r\n  const getOrCreateThread = useCallback(async (conversationId, type, entityId = null) => {\r\n    try {\r\n      let endpoint;\r\n      \r\n      if (type === 'general') {\r\n        endpoint = `/messages/conversation/${conversationId}/thread/general`;\r\n      } else if (type === 'order' && entityId) {\r\n        endpoint = `/messages/conversation/${conversationId}/thread/order/${entityId}`;\r\n      } else if (type === 'gig' && entityId) {\r\n        endpoint = `/messages/conversation/${conversationId}/thread/gig/${entityId}`;\r\n      } else {\r\n        throw new Error('Invalid thread type or missing entity ID');\r\n      }\r\n      \r\n      const response = await api.get(endpoint);\r\n      return response.data;\r\n    } catch (err) {\r\n      console.error('Error getting thread:', err);\r\n      setError('Failed to get or create thread');\r\n      return null;\r\n    }\r\n  }, []);\r\n\r\n  // Clean up when changing conversations\r\n  useEffect(() => {\r\n    return () => {\r\n      if (pollingInterval) {\r\n        clearInterval(pollingInterval);\r\n      }\r\n      setActiveThreadId(null);\r\n      setMessages([]);\r\n    };\r\n  }, [activeConversationId]);\r\n\r\n  // Context value\r\n  const value = {\r\n    activeConversationId,\r\n    activeThreadId,\r\n    messages,\r\n    isLoading,\r\n    error,\r\n    setActiveChat,\r\n    sendMessage,\r\n    loadMoreMessages,\r\n    getOrCreateThread\r\n  };\r\n\r\n  return (\r\n    <MessagingContext.Provider value={value}>\r\n      {children}\r\n    </MessagingContext.Provider>\r\n  );\r\n};\r\n\r\n// Custom hook to use the messaging context\r\nexport const useMessaging = () => {\r\n  const context = useContext(MessagingContext);\r\n  if (!context) {\r\n    throw new Error('useMessaging must be used within a MessagingProvider');\r\n  }\r\n  return context;\r\n};"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}