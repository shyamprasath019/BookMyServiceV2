{"ast":null,"code":"var _jsxFileName = \"D:\\\\Data\\\\Project\\\\claude ai\\\\BookMyServiceV2\\\\client\\\\src\\\\utils\\\\simplifiedMessagingService.js\",\n  _s = $RefreshSig$(),\n  _s2 = $RefreshSig$();\n// client/src/utils/simplifiedMessagingService.js\nimport React, { createContext, useState, useContext, useEffect, useCallback } from 'react';\nimport api from './api';\n\n// Create a messaging context\nimport { jsxDEV as _jsxDEV } from \"react/jsx-dev-runtime\";\nconst MessagingContext = /*#__PURE__*/createContext(null);\nexport const MessagingProvider = ({\n  children\n}) => {\n  _s();\n  const [activeConversationId, setActiveConversationId] = useState(null);\n  const [activeThreadId, setActiveThreadId] = useState(null);\n  const [messages, setMessages] = useState([]);\n  const [isLoading, setIsLoading] = useState(false);\n  const [error, setError] = useState(null);\n  const [pollingInterval, setPollingInterval] = useState(null);\n\n  // Fetch messages for the active thread\n  const fetchMessages = useCallback(async (threadId, page = 1, showLoading = true) => {\n    if (!threadId) return;\n    try {\n      if (showLoading) {\n        setIsLoading(true);\n      }\n      setError(null);\n      const response = await api.get(`/messages/thread/${threadId}/messages?page=${page}`);\n      if (page === 1) {\n        // First page, replace all messages\n        setMessages(response.data.messages);\n      } else {\n        // Subsequent pages, prepend to existing messages\n        setMessages(prev => [...response.data.messages, ...prev]);\n      }\n      return response.data;\n    } catch (err) {\n      console.error('Error fetching messages:', err);\n      setError('Failed to load messages');\n      return null;\n    } finally {\n      if (showLoading) {\n        setIsLoading(false);\n      }\n    }\n  }, []);\n\n  // Set active conversation and thread\n  const setActiveChat = useCallback((conversationId, threadId) => {\n    setActiveConversationId(conversationId);\n    setActiveThreadId(threadId);\n\n    // Clear existing messages when changing conversation/thread\n    setMessages([]);\n\n    // Start polling for new messages\n    if (threadId) {\n      // Clear any existing polling interval\n      if (pollingInterval) {\n        clearInterval(pollingInterval);\n      }\n\n      // Fetch messages immediately\n      fetchMessages(threadId);\n\n      // Then set up polling every 3 seconds (reduced from 5 seconds)\n      const interval = setInterval(() => {\n        fetchMessages(threadId);\n      }, 3000);\n      setPollingInterval(interval);\n    }\n  }, [fetchMessages, pollingInterval]);\n\n  // Clean up polling when component unmounts\n  useEffect(() => {\n    return () => {\n      if (pollingInterval) {\n        clearInterval(pollingInterval);\n      }\n    };\n  }, [pollingInterval]);\n\n  // Send a message\n  const sendMessage = useCallback(async (content, attachments = []) => {\n    if (!activeThreadId || !content.trim()) return null;\n    try {\n      const response = await api.post(`/messages/thread/${activeThreadId}`, {\n        content: content.trim(),\n        attachments\n      });\n\n      // Add the new message to the current messages\n      if (response.data) {\n        setMessages(prev => [...prev, response.data]);\n\n        // Fetch messages right after sending to ensure consistency\n        setTimeout(() => {\n          fetchMessages(activeThreadId, 1, false);\n        }, 500);\n      }\n      return response.data;\n    } catch (err) {\n      console.error('Error sending message:', err);\n      setError('Failed to send message');\n      return null;\n    }\n  }, [activeThreadId, fetchMessages]);\n\n  // Load more messages (pagination)\n  const loadMoreMessages = useCallback(async page => {\n    if (!activeThreadId) return null;\n    return fetchMessages(activeThreadId, page);\n  }, [activeThreadId, fetchMessages]);\n\n  // Get or create a conversation thread\n  const getOrCreateThread = useCallback(async (conversationId, type, entityId = null) => {\n    try {\n      let endpoint;\n      if (type === 'general') {\n        endpoint = `/messages/conversation/${conversationId}/thread/general`;\n      } else if (type === 'order' && entityId) {\n        endpoint = `/messages/conversation/${conversationId}/thread/order/${entityId}`;\n      } else if (type === 'gig' && entityId) {\n        endpoint = `/messages/conversation/${conversationId}/thread/gig/${entityId}`;\n      } else {\n        throw new Error('Invalid thread type or missing entity ID');\n      }\n      const response = await api.get(endpoint);\n      return response.data;\n    } catch (err) {\n      console.error('Error getting thread:', err);\n      setError('Failed to get or create thread');\n      return null;\n    }\n  }, []);\n\n  // Clean up when changing conversations\n  useEffect(() => {\n    return () => {\n      if (pollingInterval) {\n        clearInterval(pollingInterval);\n      }\n      setActiveThreadId(null);\n      setMessages([]);\n    };\n  }, [activeConversationId]);\n\n  // Context value\n  const value = {\n    activeConversationId,\n    activeThreadId,\n    messages,\n    isLoading,\n    error,\n    setActiveChat,\n    sendMessage,\n    loadMoreMessages,\n    getOrCreateThread\n  };\n  return /*#__PURE__*/_jsxDEV(MessagingContext.Provider, {\n    value: value,\n    children: children\n  }, void 0, false, {\n    fileName: _jsxFileName,\n    lineNumber: 167,\n    columnNumber: 5\n  }, this);\n};\n\n// Custom hook to use the messaging context\n_s(MessagingProvider, \"dJ1L8+qZZOdXlaVuGqcpIf07SCU=\");\n_c = MessagingProvider;\nexport const useMessaging = () => {\n  _s2();\n  const context = useContext(MessagingContext);\n  if (!context) {\n    throw new Error('useMessaging must be used within a MessagingProvider');\n  }\n  return context;\n};\n_s2(useMessaging, \"b9L3QQ+jgeyIrH0NfHrJ8nn7VMU=\");\nvar _c;\n$RefreshReg$(_c, \"MessagingProvider\");","map":{"version":3,"names":["React","createContext","useState","useContext","useEffect","useCallback","api","jsxDEV","_jsxDEV","MessagingContext","MessagingProvider","children","_s","activeConversationId","setActiveConversationId","activeThreadId","setActiveThreadId","messages","setMessages","isLoading","setIsLoading","error","setError","pollingInterval","setPollingInterval","fetchMessages","threadId","page","showLoading","response","get","data","prev","err","console","setActiveChat","conversationId","clearInterval","interval","setInterval","sendMessage","content","attachments","trim","post","setTimeout","loadMoreMessages","getOrCreateThread","type","entityId","endpoint","Error","value","Provider","fileName","_jsxFileName","lineNumber","columnNumber","_c","useMessaging","_s2","context","$RefreshReg$"],"sources":["D:/Data/Project/claude ai/BookMyServiceV2/client/src/utils/simplifiedMessagingService.js"],"sourcesContent":["// client/src/utils/simplifiedMessagingService.js\r\nimport React, { createContext, useState, useContext, useEffect, useCallback } from 'react';\r\nimport api from './api';\r\n\r\n// Create a messaging context\r\nconst MessagingContext = createContext(null);\r\n\r\nexport const MessagingProvider = ({ children }) => {\r\n  const [activeConversationId, setActiveConversationId] = useState(null);\r\n  const [activeThreadId, setActiveThreadId] = useState(null);\r\n  const [messages, setMessages] = useState([]);\r\n  const [isLoading, setIsLoading] = useState(false);\r\n  const [error, setError] = useState(null);\r\n  const [pollingInterval, setPollingInterval] = useState(null);\r\n\r\n  // Fetch messages for the active thread\r\n  const fetchMessages = useCallback(async (threadId, page = 1, showLoading = true) => {\r\n    if (!threadId) return;\r\n    \r\n    try {\r\n      if (showLoading) {\r\n        setIsLoading(true);\r\n      }\r\n      setError(null);\r\n      \r\n      const response = await api.get(`/messages/thread/${threadId}/messages?page=${page}`);\r\n      \r\n      if (page === 1) {\r\n        // First page, replace all messages\r\n        setMessages(response.data.messages);\r\n      } else {\r\n        // Subsequent pages, prepend to existing messages\r\n        setMessages(prev => [...response.data.messages, ...prev]);\r\n      }\r\n      \r\n      return response.data;\r\n    } catch (err) {\r\n      console.error('Error fetching messages:', err);\r\n      setError('Failed to load messages');\r\n      return null;\r\n    } finally {\r\n      if (showLoading) {\r\n        setIsLoading(false);\r\n      }\r\n    }\r\n  }, []);\r\n\r\n  // Set active conversation and thread\r\n  const setActiveChat = useCallback((conversationId, threadId) => {\r\n    setActiveConversationId(conversationId);\r\n    setActiveThreadId(threadId);\r\n    \r\n    // Clear existing messages when changing conversation/thread\r\n    setMessages([]);\r\n    \r\n    // Start polling for new messages\r\n    if (threadId) {\r\n      // Clear any existing polling interval\r\n      if (pollingInterval) {\r\n        clearInterval(pollingInterval);\r\n      }\r\n      \r\n      // Fetch messages immediately\r\n      fetchMessages(threadId);\r\n      \r\n      // Then set up polling every 3 seconds (reduced from 5 seconds)\r\n      const interval = setInterval(() => {\r\n        fetchMessages(threadId);\r\n      }, 3000);\r\n      \r\n      setPollingInterval(interval);\r\n    }\r\n  }, [fetchMessages, pollingInterval]);\r\n\r\n  // Clean up polling when component unmounts\r\n  useEffect(() => {\r\n    return () => {\r\n      if (pollingInterval) {\r\n        clearInterval(pollingInterval);\r\n      }\r\n    };\r\n  }, [pollingInterval]);\r\n\r\n  // Send a message\r\n  const sendMessage = useCallback(async (content, attachments = []) => {\r\n    if (!activeThreadId || !content.trim()) return null;\r\n    \r\n    try {\r\n      const response = await api.post(`/messages/thread/${activeThreadId}`, {\r\n        content: content.trim(),\r\n        attachments\r\n      });\r\n      \r\n      // Add the new message to the current messages\r\n      if (response.data) {\r\n        setMessages(prev => [...prev, response.data]);\r\n        \r\n        // Fetch messages right after sending to ensure consistency\r\n        setTimeout(() => {\r\n          fetchMessages(activeThreadId, 1, false);\r\n        }, 500);\r\n      }\r\n      \r\n      return response.data;\r\n    } catch (err) {\r\n      console.error('Error sending message:', err);\r\n      setError('Failed to send message');\r\n      return null;\r\n    }\r\n  }, [activeThreadId, fetchMessages]);\r\n\r\n  // Load more messages (pagination)\r\n  const loadMoreMessages = useCallback(async (page) => {\r\n    if (!activeThreadId) return null;\r\n    return fetchMessages(activeThreadId, page);\r\n  }, [activeThreadId, fetchMessages]);\r\n\r\n  // Get or create a conversation thread\r\n  const getOrCreateThread = useCallback(async (conversationId, type, entityId = null) => {\r\n    try {\r\n      let endpoint;\r\n      \r\n      if (type === 'general') {\r\n        endpoint = `/messages/conversation/${conversationId}/thread/general`;\r\n      } else if (type === 'order' && entityId) {\r\n        endpoint = `/messages/conversation/${conversationId}/thread/order/${entityId}`;\r\n      } else if (type === 'gig' && entityId) {\r\n        endpoint = `/messages/conversation/${conversationId}/thread/gig/${entityId}`;\r\n      } else {\r\n        throw new Error('Invalid thread type or missing entity ID');\r\n      }\r\n      \r\n      const response = await api.get(endpoint);\r\n      return response.data;\r\n    } catch (err) {\r\n      console.error('Error getting thread:', err);\r\n      setError('Failed to get or create thread');\r\n      return null;\r\n    }\r\n  }, []);\r\n\r\n  // Clean up when changing conversations\r\n  useEffect(() => {\r\n    return () => {\r\n      if (pollingInterval) {\r\n        clearInterval(pollingInterval);\r\n      }\r\n      setActiveThreadId(null);\r\n      setMessages([]);\r\n    };\r\n  }, [activeConversationId]);\r\n\r\n  // Context value\r\n  const value = {\r\n    activeConversationId,\r\n    activeThreadId,\r\n    messages,\r\n    isLoading,\r\n    error,\r\n    setActiveChat,\r\n    sendMessage,\r\n    loadMoreMessages,\r\n    getOrCreateThread\r\n  };\r\n\r\n  return (\r\n    <MessagingContext.Provider value={value}>\r\n      {children}\r\n    </MessagingContext.Provider>\r\n  );\r\n};\r\n\r\n// Custom hook to use the messaging context\r\nexport const useMessaging = () => {\r\n  const context = useContext(MessagingContext);\r\n  if (!context) {\r\n    throw new Error('useMessaging must be used within a MessagingProvider');\r\n  }\r\n  return context;\r\n};"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}