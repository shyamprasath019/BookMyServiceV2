{"ast":null,"code":"var _jsxFileName = \"D:\\\\Data\\\\Project\\\\claude ai\\\\BookMyServiceV2\\\\client\\\\src\\\\utils\\\\websocketService.js\",\n  _s = $RefreshSig$(),\n  _s2 = $RefreshSig$(),\n  _s3 = $RefreshSig$();\n// client/src/utils/websocketService.js\nimport React, { createContext, useEffect, useState, useCallback, useContext } from 'react';\nimport { AuthContext } from '../context/AuthContext';\n\n// WebSocket connection URL\nimport { jsxDEV as _jsxDEV } from \"react/jsx-dev-runtime\";\nconst WS_URL = process.env.REACT_APP_WS_URL || 'ws://localhost:5001/ws';\n\n// Create a new WebSocket service hook\nexport const useWebSocket = () => {\n  _s();\n  const [socket, setSocket] = useState(null);\n  const [isConnected, setIsConnected] = useState(false);\n  const [lastMessage, setLastMessage] = useState(null);\n  const {\n    currentUser\n  } = useContext(AuthContext);\n\n  // Initialize WebSocket connection\n  useEffect(() => {\n    if (!currentUser || !currentUser._id) return;\n\n    // Create new WebSocket connection with authentication token\n    const token = localStorage.getItem('token');\n    const ws = new WebSocket(`${WS_URL}?token=${token}`);\n\n    // Connection opened\n    ws.onopen = () => {\n      console.log('WebSocket Connected');\n      setIsConnected(true);\n\n      // Send authentication message\n      ws.send(JSON.stringify({\n        type: 'authenticate',\n        userId: currentUser._id\n      }));\n    };\n\n    // Connection closed\n    ws.onclose = event => {\n      console.log('WebSocket Disconnected', event.code, event.reason);\n      setIsConnected(false);\n\n      // Attempt to reconnect after 3 seconds if not closed intentionally\n      if (event.code !== 1000) {\n        setTimeout(() => {\n          console.log('Attempting to reconnect...');\n          // The effect cleanup will remove the old socket, and this effect will run again\n        }, 3000);\n      }\n    };\n\n    // Connection error\n    ws.onerror = error => {\n      console.error('WebSocket Error:', error);\n    };\n\n    // Listen for messages\n    ws.onmessage = event => {\n      try {\n        const message = JSON.parse(event.data);\n        setLastMessage(message);\n      } catch (e) {\n        console.error('Error parsing WebSocket message:', e);\n      }\n    };\n\n    // Set socket state\n    setSocket(ws);\n\n    // Clean up on unmount\n    return () => {\n      if (ws) {\n        ws.close(1000, 'Component unmounted');\n      }\n    };\n  }, [currentUser]);\n\n  // Send message through WebSocket\n  const sendMessage = useCallback(data => {\n    if (socket && isConnected) {\n      socket.send(JSON.stringify(data));\n      return true;\n    }\n    return false;\n  }, [socket, isConnected]);\n\n  // Join a conversation room\n  const joinConversation = useCallback(conversationId => {\n    if (!conversationId) return false;\n    return sendMessage({\n      type: 'join_conversation',\n      conversationId\n    });\n  }, [sendMessage]);\n\n  // Leave a conversation room\n  const leaveConversation = useCallback(conversationId => {\n    if (!conversationId) return false;\n    return sendMessage({\n      type: 'leave_conversation',\n      conversationId\n    });\n  }, [sendMessage]);\n\n  // Send a chat message\n  const sendChatMessage = useCallback((conversationId, content, attachments = []) => {\n    if (!conversationId || !content) return false;\n    return sendMessage({\n      type: 'chat_message',\n      conversationId,\n      content,\n      attachments\n    });\n  }, [sendMessage]);\n  const joinThread = useCallback((conversationId, threadId) => {\n    if (!conversationId || !threadId) return false;\n    return sendMessage({\n      type: 'join_thread',\n      conversationId,\n      threadId\n    });\n  }, [sendMessage]);\n  const leaveThread = useCallback((conversationId, threadId) => {\n    if (!conversationId || !threadId) return false;\n    return sendMessage({\n      type: 'leave_thread',\n      conversationId,\n      threadId\n    });\n  }, [sendMessage]);\n  const sendThreadMessage = useCallback((conversationId, threadId, content, attachments = []) => {\n    if (!conversationId || !threadId || !content) return false;\n    return sendMessage({\n      type: 'thread_message',\n      conversationId,\n      threadId,\n      content,\n      attachments\n    });\n  }, [sendMessage]);\n  return {\n    socket,\n    isConnected,\n    lastMessage,\n    sendMessage,\n    joinConversation,\n    leaveConversation,\n    sendChatMessage,\n    joinThread,\n    leaveThread,\n    sendThreadMessage\n  };\n};\n\n// Create a WebSocket context for app-wide access\n_s(useWebSocket, \"dLFhDv7/s2vl+U+3HC8yQ+tSVMo=\");\nconst WebSocketContext = /*#__PURE__*/createContext(null);\nexport const WebSocketProvider = ({\n  children\n}) => {\n  _s2();\n  const wsService = useWebSocket();\n  return /*#__PURE__*/_jsxDEV(WebSocketContext.Provider, {\n    value: wsService,\n    children: children\n  }, void 0, false, {\n    fileName: _jsxFileName,\n    lineNumber: 169,\n    columnNumber: 5\n  }, this);\n};\n_s2(WebSocketProvider, \"hJxe/vV0Wen0lriYLPNid0NSD5w=\", false, function () {\n  return [useWebSocket];\n});\n_c = WebSocketProvider;\nexport const useWebSocketContext = () => {\n  _s3();\n  return useContext(WebSocketContext);\n};\n_s3(useWebSocketContext, \"gDsCjeeItUuvgOWf1v4qoK9RF6k=\");\nvar _c;\n$RefreshReg$(_c, \"WebSocketProvider\");","map":{"version":3,"names":["React","createContext","useEffect","useState","useCallback","useContext","AuthContext","jsxDEV","_jsxDEV","WS_URL","process","env","REACT_APP_WS_URL","useWebSocket","_s","socket","setSocket","isConnected","setIsConnected","lastMessage","setLastMessage","currentUser","_id","token","localStorage","getItem","ws","WebSocket","onopen","console","log","send","JSON","stringify","type","userId","onclose","event","code","reason","setTimeout","onerror","error","onmessage","message","parse","data","e","close","sendMessage","joinConversation","conversationId","leaveConversation","sendChatMessage","content","attachments","joinThread","threadId","leaveThread","sendThreadMessage","WebSocketContext","WebSocketProvider","children","_s2","wsService","Provider","value","fileName","_jsxFileName","lineNumber","columnNumber","_c","useWebSocketContext","_s3","$RefreshReg$"],"sources":["D:/Data/Project/claude ai/BookMyServiceV2/client/src/utils/websocketService.js"],"sourcesContent":["// client/src/utils/websocketService.js\r\nimport React, { createContext, useEffect, useState, useCallback, useContext } from 'react';\r\nimport { AuthContext } from '../context/AuthContext';\r\n\r\n// WebSocket connection URL\r\nconst WS_URL = process.env.REACT_APP_WS_URL || 'ws://localhost:5001/ws';\r\n\r\n// Create a new WebSocket service hook\r\nexport const useWebSocket = () => {\r\n  const [socket, setSocket] = useState(null);\r\n  const [isConnected, setIsConnected] = useState(false);\r\n  const [lastMessage, setLastMessage] = useState(null);\r\n  const { currentUser } = useContext(AuthContext);\r\n  \r\n  // Initialize WebSocket connection\r\n  useEffect(() => {\r\n    if (!currentUser || !currentUser._id) return;\r\n    \r\n    // Create new WebSocket connection with authentication token\r\n    const token = localStorage.getItem('token');\r\n    const ws = new WebSocket(`${WS_URL}?token=${token}`);\r\n    \r\n    // Connection opened\r\n    ws.onopen = () => {\r\n      console.log('WebSocket Connected');\r\n      setIsConnected(true);\r\n      \r\n      // Send authentication message\r\n      ws.send(JSON.stringify({\r\n        type: 'authenticate',\r\n        userId: currentUser._id\r\n      }));\r\n    };\r\n    \r\n    // Connection closed\r\n    ws.onclose = (event) => {\r\n      console.log('WebSocket Disconnected', event.code, event.reason);\r\n      setIsConnected(false);\r\n      \r\n      // Attempt to reconnect after 3 seconds if not closed intentionally\r\n      if (event.code !== 1000) {\r\n        setTimeout(() => {\r\n          console.log('Attempting to reconnect...');\r\n          // The effect cleanup will remove the old socket, and this effect will run again\r\n        }, 3000);\r\n      }\r\n    };\r\n    \r\n    // Connection error\r\n    ws.onerror = (error) => {\r\n      console.error('WebSocket Error:', error);\r\n    };\r\n    \r\n    // Listen for messages\r\n    ws.onmessage = (event) => {\r\n      try {\r\n        const message = JSON.parse(event.data);\r\n        setLastMessage(message);\r\n      } catch (e) {\r\n        console.error('Error parsing WebSocket message:', e);\r\n      }\r\n    };\r\n    \r\n    // Set socket state\r\n    setSocket(ws);\r\n    \r\n    // Clean up on unmount\r\n    return () => {\r\n      if (ws) {\r\n        ws.close(1000, 'Component unmounted');\r\n      }\r\n    };\r\n  }, [currentUser]);\r\n  \r\n  // Send message through WebSocket\r\n  const sendMessage = useCallback((data) => {\r\n    if (socket && isConnected) {\r\n      socket.send(JSON.stringify(data));\r\n      return true;\r\n    }\r\n    return false;\r\n  }, [socket, isConnected]);\r\n  \r\n  // Join a conversation room\r\n  const joinConversation = useCallback((conversationId) => {\r\n    if (!conversationId) return false;\r\n    \r\n    return sendMessage({\r\n      type: 'join_conversation',\r\n      conversationId\r\n    });\r\n  }, [sendMessage]);\r\n  \r\n  // Leave a conversation room\r\n  const leaveConversation = useCallback((conversationId) => {\r\n    if (!conversationId) return false;\r\n    \r\n    return sendMessage({\r\n      type: 'leave_conversation',\r\n      conversationId\r\n    });\r\n  }, [sendMessage]);\r\n  \r\n  // Send a chat message\r\n  const sendChatMessage = useCallback((conversationId, content, attachments = []) => {\r\n    if (!conversationId || !content) return false;\r\n    \r\n    return sendMessage({\r\n      type: 'chat_message',\r\n      conversationId,\r\n      content,\r\n      attachments\r\n    });\r\n  }, [sendMessage]);\r\n\r\n  const joinThread = useCallback((conversationId, threadId) => {\r\n    if (!conversationId || !threadId) return false;\r\n    \r\n    return sendMessage({\r\n      type: 'join_thread',\r\n      conversationId,\r\n      threadId\r\n    });\r\n  }, [sendMessage]);\r\n  \r\n  const leaveThread = useCallback((conversationId, threadId) => {\r\n    if (!conversationId || !threadId) return false;\r\n    \r\n    return sendMessage({\r\n      type: 'leave_thread',\r\n      conversationId,\r\n      threadId\r\n    });\r\n  }, [sendMessage]);\r\n  \r\n  const sendThreadMessage = useCallback((conversationId, threadId, content, attachments = []) => {\r\n    if (!conversationId || !threadId || !content) return false;\r\n    \r\n    return sendMessage({\r\n      type: 'thread_message',\r\n      conversationId,\r\n      threadId,\r\n      content,\r\n      attachments\r\n    });\r\n  }, [sendMessage]);\r\n  \r\n  return {\r\n    socket,\r\n    isConnected,\r\n    lastMessage,\r\n    sendMessage,\r\n    joinConversation,\r\n    leaveConversation,\r\n    sendChatMessage,\r\n    joinThread,\r\n    leaveThread,\r\n    sendThreadMessage\r\n  };\r\n};\r\n\r\n// Create a WebSocket context for app-wide access\r\nconst WebSocketContext = createContext(null);\r\n\r\nexport const WebSocketProvider = ({ children }) => {\r\n  const wsService = useWebSocket();\r\n  \r\n  return (\r\n    <WebSocketContext.Provider value={wsService}>\r\n      {children}\r\n    </WebSocketContext.Provider>\r\n  );\r\n};\r\n\r\nexport const useWebSocketContext = () => {\r\n  return useContext(WebSocketContext);\r\n};"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}